#pragma once

#include"primitives.h"
#include"window.h"
#include"camera.h"

class Drawer {
public:
	Drawer() {
	}
	void drawVertex(Vertex vertex, Window window, Camera camera);
	void drawLine(Vertex v1, Vertex v2, Window window, Camera camera);
	void drawTriangle(Triangle triangle, Window window, Camera camera);
};



#include"drawer.h"
#include"transform.h"
#include<iostream>


//»­µã
void Drawer::drawVertex(Vertex vertex, Window window, Camera camera)
{
    /*
    red = vertex.R;
    green = vertex.G;
    blue = vertex.B;
    screen_x = sTrans(vertex.vector, window).x;
    screen_y = sTrans(vertex.vector, window).y;
    //startDraw = true;
    */
}


//»­Ïß
void Drawer::drawLine(Vertex v1, Vertex v2, Window window, Camera camera)
{
    /*
    red = v1.R;
    green = v1.G;
    blue = v1.B;
    int i, j;
    float k;
    v1.vector = transformAll(v1.vector, camera, window);
    v2.vector = transformAll(v2.vector, camera, window);
    cout << v1.vector.x << endl;
    cout << v1.vector.y << endl;
    if (v1.vector.x < v2.vector.x) {
        k = (v2.vector.y - v1.vector.y) / (v2.vector.x - v1.vector.x);
        for (i = (int)v1.vector.x; i <= (int)v2.vector.x; ++i) {
            screen_x = i;
            screen_y = (int)((k * ((float)i - v1.vector.x)) + v1.vector.y);
            startDraw = true;
        }
    }
    else {
        k = (v1.vector.y - v2.vector.y) / (v1.vector.x - v2.vector.x);
        for (i = (int)v2.vector.x; i <= (int)v1.vector.x; ++i) {
            screen_x = i;
            screen_y = (int)((k * ((float)i - v2.vector.x)) + v2.vector.y);
            startDraw = true;
        }
    }
    startDraw = false;
    */
}


//»­Èý½ÇÐÎ
void Drawer::drawTriangle(Triangle triangle, Window window, Camera camera)
{

    //this->drawLine(triangle.point1, triangle.point2, window, camera);
    //this->drawLine(triangle.point2, triangle.point3, window, camera);
    //this->drawLine(triangle.point3, triangle.point1, window, camera);
}



//(this->matrix).mat[0][0] = 1 / (camera.aspect * tan(camera.fov / 2));
//(this->matrix).mat[1][1] = 1 / tan(camera.fov / 2);

(this->matrix).mat[0][0] = (abs(a.x / a.z)) * camera.aspect;
(this->matrix).mat[1][1] = (abs(a.y / a.z));




//Ìî³äÈý½ÇÐÎ  scanline
void fillTriangle(Texture* texture, Vertex v1, Vertex v2, Vertex v3)
{
	float xMin = v1.vector.x; if (v2.vector.x < xMin) xMin = v2.vector.x; if (v3.vector.x < xMin) xMin = v3.vector.x;
	float xMax = v1.vector.x; if (v2.vector.x > xMax) xMax = v2.vector.x; if (v3.vector.x > xMax) xMax = v3.vector.x;
	float yMin = v1.vector.y; if (v2.vector.y < yMin) yMin = v2.vector.y; if (v3.vector.y < yMin) yMin = v3.vector.y;
	float yMax = v1.vector.y; if (v2.vector.y > yMax) yMax = v2.vector.y; if (v3.vector.y > yMax) yMax = v3.vector.y;

	Vector3 a1 = (v2.vector - v1.vector) % (v3.vector - v1.vector);
	Vector3 a2 = (v3.vector - v2.vector) % (v1.vector - v2.vector);
	Vector3 a3 = (v1.vector - v3.vector) % (v2.vector - v3.vector);
	Vector3 p = v1.vector;
	Vector3 b1, b2, b3;
	int s;
	
	for (int i = xMin; i <= xMax; ++i)
	{
		for (int j = yMin; j <= yMax; ++j)
		{
			// ¼ÆËãÊÇ·ñÔÚÈý½ÇÐÎÄÚ²¿
			p.x = i;
			p.y = j;
			b1 = (v2.vector - v1.vector) % (p - v1.vector);
			b2 = (v3.vector - v2.vector) % (p - v2.vector);
			b3 = (v1.vector - v3.vector) % (p - v3.vector);

			if ((a1 * b1 >= 0) && (a2 * b2 >= 0) && (a3 * b3 >= 0)) {
				s = j * texture->width + i;
				(texture->colorBuff)[s] = v1.color;
			}
		}
	}
}


vertexBuff[VERTEXNUMS] = {        //¶¥µã»º´æ
		{ -0.1f, -0.3f, 0.0f },
		{ -0.3f, -0.3f, 0.0f },
		{ -0.1f, -0.1f, 0.0f },
		{ -0.3f, -0.1f, 0.0f },
		{ -0.3f, -0.1f, 0.3f },
		{ -0.3f, -0.3f, 0.0f },
		{ -0.3f, -0.3f, 0.3f },
		{ -0.1f, -0.3f, 0.0f },
		{ -0.1f, -0.3f, 0.3f },
		{ -0.1f, -0.1f, 0.0f },
		{ -0.1f, -0.1f, 0.3f },
		{ -0.3f, -0.1f, 0.3f },
		{ -0.1f, -0.3f, 0.3f },
		{ -0.3f, -0.3f, 0.3f }, };



		this->vertexBuff[0] = { -0.1f, -0.3f, 0.0f };       //¶¥µã»º³å
		this->vertexBuff[1] = { -0.3f, -0.3f, 0.0f };
		this->vertexBuff[2] = { -0.1f, -0.1f, 0.0f };
		this->vertexBuff[3] = { -0.3f, -0.1f, 0.0f };
		this->vertexBuff[4] = { -0.3f, -0.1f, 0.3f };
		this->vertexBuff[5] = { -0.3f, -0.3f, 0.0f };
		this->vertexBuff[6] = { -0.3f, -0.3f, 0.3f };
		this->vertexBuff[7] = { -0.1f, -0.3f, 0.0f };
		this->vertexBuff[8] = { -0.1f, -0.3f, 0.3f };
		this->vertexBuff[9] = { -0.1f, -0.1f, 0.0f };
		this->vertexBuff[10] = { -0.1f, -0.1f, 0.3f };
		this->vertexBuff[11] = { -0.3f, -0.1f, 0.3f };
		this->vertexBuff[12] = { -0.1f, -0.3f, 0.3f };
		this->vertexBuff[13] = { -0.3f, -0.3f, 0.3f };



		//int i = (int)v.vector.y * texture->width + (int)v.vector.x;
	//(texture->colorBuff)[i] = v.color;





	if (v1.vector.x < v2.vector.x) {
		k1 = (v2.vector.y - v1.vector.y) / (v2.vector.x - v1.vector.x);
		k2 = (v2.vector.z - v1.vector.z) / (v2.vector.x - v1.vector.x);
		for (i = (int)v1.vector.x; i <= (int)v2.vector.x; ++i) {
			screen_x = i;
			screen_y = (int)((k1 * ((float)i - v1.vector.x)) + v1.vector.y);
			z = k2 * ((float)i - v1.vector.x) + v1.vector.z;

			//Î´³¬³öÆÁÄ»
			if (!(outofScreen(screen_x, screen_y, z, texture))) {
				s = screen_y * texture->width + screen_x;
				(texture->colorBuff)[s] = v1.color;
				if ((k1 > 1 || k1 < -1) && (screen_y < texture->height - 1)) {
					screen_y += 1;
					s = screen_y * texture->width + screen_x;
					(texture->colorBuff)[s] = v1.color;
				}
			}
		}
	}
	else if (v1.vector.x > v2.vector.x) {
		k1 = (v1.vector.y - v2.vector.y) / (v1.vector.x - v2.vector.x);
		k2 = (v1.vector.z - v2.vector.z) / (v1.vector.x - v2.vector.x);
		for (i = (int)v2.vector.x; i <= (int)v1.vector.x; ++i) {
			screen_x = i;
			screen_y = (int)((k1 * ((float)i - v2.vector.x)) + v2.vector.y);
			z = k2 * ((float)i - v2.vector.x) + v2.vector.z;

			//Î´³¬³öÆÁÄ»
			if (!(outofScreen(screen_x, screen_y, z, texture))) {
				s = screen_y * texture->width + screen_x;
				(texture->colorBuff)[s] = v1.color;
				if ((k1 > 1 || k1 < -1) && (screen_y < texture->height - 1)) {
					screen_y += 1;
					s = screen_y * texture->width + screen_x;
					(texture->colorBuff)[s] = v1.color;
				}
			}
		}
	}




	(this->matrix).mat[0][0] = camera.xDirect.x;    (this->matrix).mat[0][1] = camera.xDirect.y;   (this->matrix).mat[0][2] = camera.xDirect.z;
    (this->matrix).mat[1][0] = y.x;                 (this->matrix).mat[1][1] = y.y;                (this->matrix).mat[1][2] = y.z;
    (this->matrix).mat[2][0] = camera.target.x;     (this->matrix).mat[2][1] = camera.target.y;    (this->matrix).mat[2][2] = camera.target.z;
    (this->matrix).mat[3][0] = -camera.position.x;  
    (this->matrix).mat[3][1] = -camera.position.y; 
    (this->matrix).mat[3][2] = -camera.position.z;




	#include"drawer.h"
#include"primitives.h"
#include"shader.h"
#include"engine.h"

extern Device* device;


//Ìî³äÌùÍ¼
void fillTexture(unsigned int color, Texture* texture) 
{
	for (int row = 0; row < texture->height; ++row)
	{
		for (int col = 0; col < texture->width; ++col)
		{
			int idx = row * texture->width + col;

			(texture->colorBuff)[idx] = color;

			device->depthBuffer[idx] = 1.0f;
		}
	}
}


//ÊÇ·ñ³¬³öÆÁÄ»
bool outofScreen(int x, int y, float z, Texture* texture)
{
	if (x >= 0 && x < texture->width && y >= 0 && y < texture->height && z >= 0.0f && z <= 1.0f) {
		return false;
	}
	else {
		return true;
	}
}


//»­µã
void drawVertex(Texture* texture, Vertex vertex)
{
	//¶¥µã×ÅÉ«Æ÷
	Vertex v = vertexShader(vertex);

	//Î´³¬³öÆÁÄ»
	if (!(outofScreen((int)v.vector.x, (int)v.vector.y, v.vector.z, texture))) {
		int i = (int)v.vector.y * texture->width + (int)v.vector.x;
		(texture->colorBuff)[i] = v.color;
	}
	return;
}


//»­Ïß  DDAËã·¨
void drawLine(Texture* texture, Vertex v1, Vertex v2)
{
	v1 = vertexShader(v1);
	v2 = vertexShader(v2);

	Vertex xMin, xMax, yMin, yMax;
	int i, screen_x, screen_y, s, situation;
	float k1, k2, z;

	if (v1.vector.x < v2.vector.x) {
		xMin = v1;
		xMax = v2;
		situation = 1;
	}
	else if (v1.vector.x > v2.vector.x) {
		xMin = v2;
		xMax = v1;
		situation = 1;
	}
	else {
		situation = 2;
		if (v1.vector.y < v2.vector.y) {
			yMin = v1;
			yMax = v2;
		}
		else if (v1.vector.y > v2.vector.y) {
			yMin = v2;
			yMax = v1;
		}
		else {
			situation = 3;
		}
	}

	if (situation == 1) {
		k1 = (xMax.vector.y - xMin.vector.y) / (xMax.vector.x - xMin.vector.x);
		k2 = (xMax.vector.z - xMin.vector.z) / (xMax.vector.x - xMin.vector.x);
		for (i = (int)xMin.vector.x; i <= (int)xMax.vector.x; ++i) {
			screen_x = i;
			screen_y = (int)((k1 * ((float)i - xMin.vector.x)) + xMin.vector.y);
			z = k2 * ((float)i - xMin.vector.x) + xMin.vector.z;

			//Î´³¬³öÆÁÄ»
			if (!(outofScreen(screen_x, screen_y, z, texture))) {
				s = screen_y * texture->width + screen_x;
				(texture->colorBuff)[s] = xMin.color;
				if ((k1 > 1 || k1 < -1) && (screen_y < texture->height - 1)) {
					screen_y += 1;
					s = screen_y * texture->width + screen_x;
					(texture->colorBuff)[s] = xMin.color;
				}
			}
		}
	}
	else if (situation == 2) {
		screen_x = yMin.vector.x;
		for (i = (int)yMin.vector.y; i <= (int)yMax.vector.y; ++i) {
			screen_y = i;
			k2 = (i - yMin.vector.y) / (yMax.vector.y - yMin.vector.y);
			z = k2 * (yMax.vector.z - yMin.vector.z) + yMin.vector.z;

			//Î´³¬³öÆÁÄ»
			if (!(outofScreen(screen_x, screen_y, z, texture))) {
				s = screen_y * texture->width + screen_x;
				(texture->colorBuff)[s] = xMin.color;
			}
		}
	}
	else if (situation == 3) {
		screen_x = v1.vector.x;
		screen_y = v1.vector.y;
		if (v1.vector.z < v2.vector.z) {
			z = v1.vector.z;
		}
		else {
			z = v2.vector.z;
		}

		//Î´³¬³öÆÁÄ»
		if (!(outofScreen(screen_x, screen_y, z, texture))) {
			s = screen_y * texture->width + screen_x;
			(texture->colorBuff)[s] = v1.color;
		}
	}
}


//»­Èý½ÇÐÎ
void drawTriangle(Texture* texture, Triangle triangle)
{
	Vertex v1 = vertexShader(triangle.point1);
	Vertex v2 = vertexShader(triangle.point2);
	Vertex v3 = vertexShader(triangle.point3);
	fillTriangle(texture, v1, v2, v3);
}


//Ìî³äÈý½ÇÐÎ  scanline
void fillTriangle(Texture* texture, Vertex v1, Vertex v2, Vertex v3)
{
	float xMin = v1.vector.x; if (v2.vector.x < xMin) xMin = v2.vector.x; if (v3.vector.x < xMin) xMin = v3.vector.x;
	float xMax = v1.vector.x; if (v2.vector.x > xMax) xMax = v2.vector.x; if (v3.vector.x > xMax) xMax = v3.vector.x;
	float yMin = v1.vector.y; if (v2.vector.y < yMin) yMin = v2.vector.y; if (v3.vector.y < yMin) yMin = v3.vector.y;
	float yMax = v1.vector.y; if (v2.vector.y > yMax) yMax = v2.vector.y; if (v3.vector.y > yMax) yMax = v3.vector.y;

	Vector3 a1 = (v2.vector - v1.vector) % (v3.vector - v1.vector);
	Vector3 a2 = (v3.vector - v2.vector) % (v1.vector - v2.vector);
	Vector3 a3 = (v1.vector - v3.vector) % (v2.vector - v3.vector);
	Vertex p = v1;
	Vector3 m;
	Vector3 b1, b2, b3;
	int s;

	for (int i = xMin; i <= xMax; ++i)
	{
		for (int j = yMin; j <= yMax; ++j)
		{
			// ¼ÆËãÊÇ·ñÔÚÈý½ÇÐÎÄÚ²¿
			p.vector.x = i;
			p.vector.y = j;
			b1 = (v2.vector - v1.vector) % (p.vector - v1.vector);
			b2 = (v3.vector - v2.vector) % (p.vector - v2.vector);
			b3 = (v1.vector - v3.vector) % (p.vector - v3.vector);

			//ÔÚÈý½ÇÐÎÄÚ
			if ((a1 * b1 >= 0) && (a2 * b2 >= 0) && (a3 * b3 >= 0)) {

				if (a1.z != 0.0f) {
					m = p.vector - v1.vector;
					m.z = -((a1.x * m.x) + (a1.y * m.y)) / a1.z;
					p.vector.z = m.z + v1.vector.z;
				}
				else {
					p.vector.z = 1.0f;
				}

				//²Ã¼ô
				if (i >= 0 && i < texture->width && j >= 0 && j < texture->height && p.vector.z >= 0.0f && p.vector.z <= 1.0f) {
				    
					//Éî¶È²âÊÔ 
					s = j * texture->width + i;
					if (p.vector.z <= device->depthBuffer[s]) {

						//ÏñËØ×ÅÉ«Æ÷
						p = pixelShader(p);

						(texture->colorBuff)[s] = p.color;
						device->depthBuffer[s] = p.vector.z;
					}
				}
			}
		}
	}
}



